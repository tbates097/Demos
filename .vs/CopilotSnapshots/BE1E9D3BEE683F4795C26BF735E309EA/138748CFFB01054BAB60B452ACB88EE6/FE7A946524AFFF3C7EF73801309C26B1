import tkinter as tk
from tkinter import ttk
import sys
import time
from DecodeFaults import decode_faults

# Make sure the Logger.py file is in the same directory as this script
sys.path.append(r"K:\10. Released Software\Shared Python Programs\production-2.1")
from Logger import TextLogger

# --- Main Application Window ---
root = tk.Tk()
root.title("TextLogger Demo")
root.geometry("700x500")
root.minsize(500, 300)

# --- Create a PanedWindow for resizable layout ---
paned_window = ttk.PanedWindow(root, orient=tk.HORIZONTAL)
paned_window.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

# --- Frame for Control Buttons ---
controls_frame = ttk.Frame(paned_window, width=200, height=400)
controls_frame.pack_propagate(False) # Prevent frame from shrinking
paned_window.add(controls_frame, weight=1)

# --- Text Widget and Logger ---
text_frame = ttk.Frame(paned_window, width=500, height=400)
paned_window.add(text_frame, weight=3)

# Create the Text widget that the logger will use
log_widget = tk.Text(text_frame, wrap=tk.WORD, state=tk.DISABLED, font=("Courier New", 10))
log_widget.pack(padx=5, pady=5, expand=True, fill=tk.BOTH)

# Create the logger instance
logger = TextLogger(log_widget)

# --- Mock Classes from DecodeFaults_demo.py ---
class MockLogger:
    def error(self, message):
        print(f"LOGGER [ERROR]: {message}")

class MockA1Commands:
    def acknowledgeall(self, keep_enabled_state):
        print(f"CONTROLLER: AcknowledgeAll command received (keep_enabled_state={keep_enabled_state}).")

class MockA1Runtime:
    def __init__(self):
        class FaultAndError:
            def __init__(self):
                self.acknowledgeall = MockA1Commands().acknowledgeall
        self.commands = type('Commands', (), {'fault_and_error': FaultAndError()})()

class MockController:
    def __init__(self):
        self.runtime = MockA1Runtime()

# --- Fault Data Setup ---
AXES_LIST = ['AxisX', 'AxisY', 'AxisZ']
FAULTS_DATA = {
    'AxisX': 65,  # (1 << 0) | (1 << 6)
    'AxisY': 2,   # (1 << 1)
    'AxisZ': 0    # No faults
}

# --- Demonstration Functions ---

def demo_write_and_print():
    """
    Demonstrates appending text using both logger.write()
    and the standard print() function after redirecting stdout.
    """
    logger.write("--- Starting Demo ---\n")
    logger.write("This message was written using logger.write().\n")
    
    # Redirect stdout to the logger
    sys.stdout = logger
    
    print("This message was written using the standard print() function.")
    print("Any output from print() will now appear in the Text widget.")
    for i in range(3):
        print(f"Counting... {i+1}")
        # time.sleep(0.5) # Uncomment to see messages appear sequentially
    print("--- Demo Finished ---\n")

    # It's good practice to restore stdout if you only need to redirect it temporarily
    # sys.stdout = sys.__stdout__

def demo_overwrite():
    """
    Demonstrates clearing the widget and writing new content
    with a single command.
    """
    logger.write_overwrite("This message has completely replaced the old content.\n"
                           "Useful for displaying status updates that don't need history.")

def demo_read_input():
    """
    Demonstrates capturing user input from within the Text widget.
    Note: This is a blocking call; the GUI will wait until the user
    presses Enter.
    """
    sys.stdout = logger # Ensure print works
    print("\n--- Starting Input Demo ---")
    print("Please type your name below and press Enter.")
    
    # The read_input() method displays a prompt and waits for the user
    name = logger.read_input()
    
    if name:
        print(f"Hello, {name}! Your input was captured successfully.")
    else:
        print("Input cancelled or empty.")
    print("--- Input Demo Finished ---\n")

def demo_clear():
    """Demonstrates clearing the text widget."""
    logger.clear()
    logger.write("Log cleared.\n")

def demo_decode_faults():
    """
    Demonstrates decoding faults and displaying results in the logger widget.
    """
    logger.write("--- Starting Fault Decoding Demo ---\n")
    logger.write(f"Initial fault codes: {FAULTS_DATA}\n\n")
    sys.stdout = logger
    # Use the TextLogger for error output as well
    class GuiLogger:
        def error(self, message):
            print(f"LOGGER [ERROR]: {message}")
    gui_logger = GuiLogger()
    mock_controller = MockController()
    fault_decoder = decode_faults(
        faults_per_axis=FAULTS_DATA,
        connected_axes=AXES_LIST,
        controller=mock_controller,
        fault_log=gui_logger
    )
    decoded_results = fault_decoder.get_fault()
    print("\n--- Decoding Complete ---")
    print("Returned dictionary of decoded faults:")
    print(decoded_results)
    logger.write("\n")
    # sys.stdout = sys.__stdout__  # Optionally restore

# --- Configure and Place Buttons ---
style = ttk.Style()
style.configure("TButton", padding=6, relief="flat", font=('Helvetica', 10))

btn_write = ttk.Button(controls_frame, text="Write & Print", command=demo_write_and_print)
btn_write.pack(padx=10, pady=(10, 5), fill=tk.X)

btn_overwrite = ttk.Button(controls_frame, text="Overwrite Content", command=demo_overwrite)
btn_overwrite.pack(padx=10, pady=5, fill=tk.X)

btn_input = ttk.Button(controls_frame, text="Ask for Input", command=demo_read_input)
btn_input.pack(padx=10, pady=5, fill=tk.X)

btn_clear = ttk.Button(controls_frame, text="Clear Log", command=demo_clear)
btn_clear.pack(padx=10, pady=5, fill=tk.X)

btn_decode_faults = ttk.Button(controls_frame, text="Decode Faults", command=demo_decode_faults)
btn_decode_faults.pack(padx=10, pady=5, fill=tk.X)

# --- Start the Application ---
# Greet the user on startup
logger.write("Welcome to the TextLogger Demo!\n"
             "Click the buttons on the left to see the logger in action.\n")

root.mainloop()